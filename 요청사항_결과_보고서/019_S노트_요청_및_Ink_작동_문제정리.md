# S노트 스타일 요청 · Ink 작동 방식 · 수정 요구사항 · 발생 문제점

---

## 1. S노트처럼 해달라는 요청

사용자가 **삼성 노트(Samsung Notes)** 에서의 “삽입된 이미지(사진)” 조작 방식을 참고해, **Ink 앱에서도 비슷하게** 동작하도록 해달라는 요청입니다.

### 1.1 S노트에서의 이미지 조작 (공식 문서 기준)

| 구분 | 내용 |
|------|------|
| **이미지 삽입** | Insert(+) → Image → 갤러리 등에서 선택 |
| **리사이즈** | 이미지 **테두리/모서리** 드래그로 크기 조절 |
| **팝업 메뉴** | 이미지 위(또는 근처)에 뜨는 옵션 (회전/자르기/비율 등) |
| **선택 모드** | 라쏘/사각 선택 후, 선택된 항목 **이동(move)·회전(rotate)·크기조절(resize)** 가능 |

### 1.2 사용자가 원하는 UX (S노트 스타일)

- **기본 상태**  
  - 1손가락 드래그 = **캔버스 이동**  
  - 2손가락 핀치 = **캔버스 줌**

- **사진 선택(탭) 상태**  
  - 사진 **위**에서 1손가락 드래그 = **사진 이동**  
  - **모서리 핸들** 드래그 = 비율 유지 리사이즈  
  - **변(에지) 핸들** 드래그 = 가로/세로 자유 리사이즈  
  - **회전 핸들** 드래그 = 오브젝트 중심 기준 회전  

- **선택 해제**  
  - 사진 **밖** 탭 = 선택 해제 → 다시 캔버스 이동/줌으로 복귀  

즉, **“선택된 오브젝트가 있으면 오브젝트 제스처(이동/리사이즈/회전)가 우선”** 되고, **선택이 없으면 캔버스 제스처(이동/줌)가 동작**하는 구조를 요청한 것입니다.

---

## 2. Ink 코드 작동 방식

### 2.1 터치/제스처가 처리되는 구조 (현재 Ink)

Ink 캔버스는 대략 아래와 같은 **위젯 트리**로 터치와 제스처를 처리합니다.

```
MouseRegion
  └─ Listener          ← onPointerDown/Move/Up (펜·손가락 좌표 → 그리기/지우개)
       └─ GestureDetector   ← onScaleStart/Update/End (캔버스 이동·핀치줌), onTapUp, onLongPress
            └─ LayoutBuilder
                 └─ RepaintBoundary
                      └─ Stack
                           ├─ ClipRect + CustomPaint   (캔버스 배경·격자·도형)
                           ├─ MediaWidget들            (이미지/영상/PDF, 각각 GestureDetector로 pan/리사이즈)
                           ├─ ClipRect + CustomPaint   (손글씨 스트로크)
                           ├─ 텍스트, 툴팁, 타임라인 등
                           └─ …
```

- **Listener**: 모든 포인터 이벤트를 먼저 받아서, **펜/지우개**로 그리기·지우기 좌표를 처리합니다. (손글씨는 여기서 정상 동작)
- **GestureDetector**: 그 **아래**에서 **같은 터치**에 대해 scale(이동·줌), tap, longPress를 처리합니다.
- **Stack 자식들**:  
  - 캔버스는 **그리기만** 하는 ClipRect+CustomPaint.  
  - **미디어**는 각각 `MediaWidget` 안에 **또 다른 GestureDetector**(onPanStart/Update/End)로 이동·리사이즈·회전을 처리합니다.

같은 손가락 드래그에 대해 **위쪽의 캔버스용 GestureDetector**와 **아래쪽 미디어용 GestureDetector**가 **동시에** 터치를 “받을 수 있는” 구조입니다. Flutter 제스처 경쟁(arena)에서 **어느 쪽이 이기느냐**에 따라 “캔버스가 움직이거나” “사진이 움직이거나” 결정됩니다.

### 2.2 S노트 스타일을 적용했을 때 시도한 방식

S노트처럼 “선택된 사진 위에서는 **사진만** 이동, 빈 곳에서는 **캔버스만** 이동”이 되게 하려고, 아래와 같이 바꿨습니다.

- **캔버스용 GestureDetector**를 Stack **안**으로 넣음.
- Stack의 **첫 번째 자식**을  
  `Positioned.fill` → **`_MediaAwareHitTestBlock`** → GestureDetector → … → CustomPaint  
  로 두고,  
  **“터치 좌표가 선택된(크기조정 중) 미디어 영역(회전 반영) 안이면 이 레이어는 hitTest에서 false”** 로 해서,  
  **사진 위**에서는 캔버스 레이어가 터치를 “못 받고”, **빈 영역**에서만 캔버스 pan/zoom이 받도록 의도했습니다.

즉, **Ink 코드 작동 방식**은:

- 터치 시 **히트 테스트**로 “어느 위젯이 터치를 받을지” 정해지고,
- 그 위젯에 붙은 **GestureDetector**만 제스처 경쟁에 참여하며,
- **모드 분리**를 “선택된 미디어 위에서는 캔버스 레이어를 히트 테스트에서 제외”하는 방식으로 구현한 것입니다.

---

## 3. 수정 요구 사항 (S노트 스타일 구현 관점)

문서/요청을 기준으로 정리한 **구체적인 수정 요구 사항**입니다.

| 번호 | 요구 사항 | 설명 |
|------|-----------|------|
| 1 | **모드 분리** | 기본 = 캔버스 이동/줌, **사진 선택 시** = 사진 이동·리사이즈·회전이 우선. |
| 2 | **Hit-test 분리** | 터치가 “사진의 변환된 영역(회전·스케일 포함)” 안이면 → 사진 선택/드래그로 처리. 바깥이면 → 캔버스 패닝/줌. |
| 3 | **Transform 분리** | 캔버스 = 뷰 변환(translate/scale). 사진 = 개별 오브젝트 변환(translate/scale/rotate). 이벤트는 화면 좌표 → 캔버스 역변환 후 오브젝트 변환 적용. |
| 4 | **제스처 우선순위** | “선택된 사진이 있을 때” 1손가락 드래그는 **사진 이동 우선**. 2손가락은 정책에 따라 사진 변형 vs 캔버스 줌 결정. |
| 5 | **핸들 규칙** | 모서리 = 비율 유지 스케일. 변 = 비율 깨지는 스케일(선택). **회전 핸들** = 오브젝트 중심 기준 회전. |
| 6 | **회전 포함 hit-test** | 회전된 사각형 안인지 판별할 수 있는 Matrix/수식 처리. |
| 7 | **탭 아웃사이드** | 사진 밖 탭 시 선택 해제 → 캔버스 조작으로 복귀. |

Ink 쪽에서는 **1, 2, 4, 5, 6, 7**을 반영하려 했고, **3(Transform 분리)** 는 기존 캔버스/미디어 좌표계로 이미 부분적으로 맞춰져 있습니다.

---

## 4. 발생하는 문제점

S노트 스타일을 Ink 코드에 적용했을 때, **두 가지가 동시에 만족되지 않는** 문제가 있습니다.

### 4.1 문제 1: “모드 분리” 구조로 가면 → **캔버스 이동·줌이 안 됨**

**구조**:  
캔버스용 GestureDetector를 Stack **안**에 두고, 선택된 미디어 위에서는 **캔버스 레이어가 hitTest에서 제외**되도록 `_MediaAwareHitTestBlock` 사용.

- **의도**:  
  빈 영역 터치 시에만 캔버스 pan/zoom이 동작하고, 사진 위 터치 시에는 사진만 이동.

- **실제**:  
  - **손글씨(펜)** 는 **정상** (Listener가 포인터를 받아서 그리기 처리).  
  - **캔버스 이동·핀치 줌**은 **동작하지 않음**.

- **원인 추정**:  
  Stack 내부에서의 **히트 테스트 순서** 또는 **제스처 경쟁** 때문에, “빈 영역”을 터치해도 캔버스용 scale 제스처가 경쟁에서 이기지 못하거나, 해당 레이어가 기대대로 터치를 받지 못하는 상황으로 보임. (Flutter의 Stack은 자식을 역순으로 히트 테스트함.)

### 4.2 문제 2: “캔버스가 동작하도록” 복구한 **현재 상태** → **사진 선택 시 캔버스·이미지 둘 다 안 움직임**

**구조**:  
캔버스용 GestureDetector를 Stack **밖**(Listener 직하위)으로 다시 올림.  
→ 현재 Ink 코드가 이 구조로 **복구된 상태**입니다.

- **의도**:  
  캔버스 이동·줌을 확실히 동작시키기.

- **실제**:  
  - **빈 영역**에서 1손가락 드래그·2손가락 핀치 → **캔버스 이동·줌 정상**.  
  - **손글씨** → **정상**.  
  - **사진 선택 후(크기조정 모드)** 사진 위에서 1손가락 드래그 → **캔버스도 이미지도 둘 다 안 움직임**.

- **원인 (정확)**  
  Flutter에서 **부모 onScale + 자식 onPan** 이 혼합되면 **GestureArena**가 꼬이는 패턴이 자주 발생함.  
  - **(A)** 두 recognizer가 같은 포인터 스트림을 놓고 경쟁하다가, 어떤 조건에서는 둘 다 accept 못 하고 reject/hold로 들어가 **“아무도 업데이트 못 받는”** 상태가 됨.  
  - **(B)** 그 위에, **상위 `_onScaleUpdate`에서 `isInMediaResizeMode`일 때 무조건 `return`** 해서 캔버스 pan을 아예 막고 있었음 → “사진 선택 시 캔버스는 의도적으로 안 움직임”.  
  - **(C)** 미디어 이동은 MediaWidget의 onPan에만 있었는데, 부모 scale과 경쟁에서 지거나 같이 꼬여서 **이미지도 안 움직임**.  
  → 결과적으로 **“사진 선택 후 드래그 시 캔버스·이미지 둘 다 안 움직임”**.

### 4.3 정리

| 상태 | 캔버스 이동·줌 | 손글씨 | 사진 이동(선택 후 드래그) |
|------|----------------|--------|---------------------------|
| **모드 분리 시도** (Block 사용) | ❌ 안 됨 | ✅ 됨 | (이론상 됨) |
| **현재 복구 상태** (GestureDetector 바깥) | ✅ 빈 영역에서 됨 | ✅ 됨 | ❌ **사진 선택 시 캔버스·이미지 둘 다 안 움직임** |

즉, **사진 선택 시**에는 **캔버스 이동**과 **이미지 이동**이 **둘 다 동작하지 않는** 문제가 있습니다.

---

## 5. 요약

- **요청**: S노트처럼 “기본 = 캔버스 이동/줌, 사진 선택 시 = 사진 이동·리사이즈·회전 우선”으로 동작.
- **Ink 작동 방식**: Listener(그리기) + GestureDetector(캔버스 pan/zoom)가 전체를 감싸고, Stack 안에 미디어별 GestureDetector가 있어서, **같은 터치에 대해 제스처 경쟁**이 일어남.  
  모드 분리를 “선택된 미디어 위에서는 캔버스 레이어를 hitTest에서 제외”하는 방식으로 시도함.
- **수정 요구 사항**: 모드 분리, hit-test/회전 포함 판정, 제스처 우선순위, 핸들·탭 아웃사이드 등 (위 표 참고).
- **발생 문제**:  
  - 모드 분리(Block) 구조 → **캔버스 이동·줌 불가**.  
  - 현재 복구 상태(GestureDetector 바깥) → **사진 선택 시 캔버스·이미지 둘 다 안 움직임**.  

**해결 (적용함)**  
**단일 제스처 라우터**로 통일함.  
- **Stack 바깥 GestureDetector 하나**에서만 캔버스 이동/줌과 미디어 이동을 처리.  
- **onScaleStart**에서 이번 제스처의 타겟을 **캔버스 vs 미디어** 중 하나로 **락**하고 끝까지 유지.  
  - 선택된 미디어가 있고, 터치가 회전 포함 히트 안이면 → `_gestureTarget = media`, `_activeMediaId = media.id`.  
  - 그 외 → `_gestureTarget = canvas`.  
- **onScaleUpdate**에서 `_gestureTarget == media`면 `moveMedia(id, focalPointDelta / canvasScale)`만 호출,  
  `_gestureTarget == canvas`면 기존대로 pan/zoom.  
- **MediaWidget**에서는 **본체 이동용 onPan 제거** (탭·롱프레스·리사이즈/회전 핸들은 유지).  
  - 리사이즈는 **각 핸들 위젯에만** GestureDetector(onPan) 두어, 본체와 제스처 경쟁이 나지 않게 함.  
이렇게 하면 “둘 다 안 움직임”과 “경쟁”이 동시에 사라짐.

---

## 6. “둘 다 안 움직임” 원인 후보 3가지 (참고)

| 후보 | 설명 |
|------|------|
| **A. 부모 onScale + 자식 onPan 혼합** | 두 recognizer가 같은 포인터 스트림을 놓고 경쟁하다가, 조건에 따라 둘 다 accept 못 하고 reject/hold로 들어가 “아무도 업데이트 못 받는” 상태가 됨. |
| **B. Listener가 이벤트 소비/잠금** | 펜·터치 처리 로직에서 “drawing 중” 플래그나 stylus/touch 구분이 꼬여, touch도 drawing으로 처리되거나 그 상태에서 canvas/move 업데이트를 막는 guard가 걸림. (현재 Ink는 stylus/mouse만 그리기, finger는 제스처로 분기하므로 B 가능성은 상대적으로 낮음.) |
| **C. 좌표계 보정 누락** | focalPointDelta를 그대로 쓰거나 보정이 잘못되어, “움직이긴 하는데 0에 가까워서 안 움직이는 것처럼” 보이는 경우. (증상이 “완전 정지”에 가깝다면 A/B가 더 유력.) |

현재 Ink에서는 **A + 상위에서 `isInMediaResizeMode`일 때 return** 이 결합된 것이 주 원인으로 보임.

---

## 7. 적용한 최종 구조 (S노트 스타일)

- **위젯 트리**: `Listener(펜/지우개)` → `GestureDetector(onScale)` ← **여기서만** 캔버스/미디어 모두 제어 → `LayoutBuilder` → `Stack(캔버스 paint, 미디어 위젯들은 표시만)`.
- **MediaWidget**: 탭·롱프레스(선택), **핸들 드래그(리사이즈/회전)** 만 내부에서 처리. **“본체 드래그로 이동”은 상위 onScale에서 타겟 락으로 처리**.
- **onScaleStart**: `_transformPoint(details.focalPoint)` 로 캔버스 좌표 계산 → 선택된 미디어 있고 회전 포함 히트 안이면 `_gestureTarget = media`, 아니면 `_gestureTarget = canvas`.
- **onScaleUpdate**: `_gestureTarget == media` → `moveMedia(id, focalPointDelta / canvasScale)`; `_gestureTarget == canvas` → 기존 pan/zoom.
- **onScaleEnd**: `_gestureTarget = none`, `_activeMediaId = null`.
